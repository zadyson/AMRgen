---
title: "Analysing Geno-Pheno Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysing Geno-Pheno Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 10,
  out.width = "100%"
)
```

# Introduction

`AMRgen` is a comprehensive R package designed to integrate antimicrobial resistance genotype and phenotype data. It provides tools to:

* Import AMR genotype data (e.g. from AMRFinderPlus, hAMRonization)

* Import AST phenotype data (e.g. public data from NCBI or EBI, or your own data in formats like Vitek or WHOnet)

* Conduct genotype-phenotype analyses to explore the impact of genotypic markers on phenotype, including via logistic regression, solo marker analysis, and upset plots

* Fetch MIC or disk zone reference distributions from EUCAST

This vignette walks through a basic workflow using example datasets included in the `AMRgen` package, and explains how to wrangle your own data files into the right formats to use the same workflow.

Start by loading the package:

```{r setup}
library(AMRgen)
library(dplyr)
```

## 1. Genotype table
The `import_amrfp()` function lets you load genotype data from AMRFinderPlus output files, and process it to generate an object with the key columns needed to work with the `AMRgen` package.

``` {r import_amrfp}
# Example AMRFinderPlus genotyping output (from Allthebacteria project)
ecoli_geno_raw

# Load AMRFinderPlus output
#    (replace 'ecoli_geno_raw' with the filepath for any AMRFinderPlus output)
ecoli_geno <- import_amrfp(ecoli_geno_raw, "Name")

# Check the format of the processed genotype table
head(ecoli_geno)
```

The genotype table has one row for each genetic marker detected in an input genome, i.e. one per strain/marker combination.

If your genotype data is not in AMRFinderPlus format, you can wrangle other input data files into the necessary format.

The essential columns for a genotype table to work with `AMRgen` functions are:

* `Name`: character string giving the sample name, used to link to sample names in the phenotype file (this column can have a different name, in which case you'll need to make sure it is the first column in the dataframe OR pass its name to the functions using `geno_sample_col`)

* `marker`: character string giving the name of the genetic marker detected

* `drug_class`: character string giving the antibiotic class associated with this marker

NOTE: You should consider whether you have genomes with no AMR markers detected by genotyping, and how to make sure these are include in your analyses. E.g. AMRFinderPlus will output one row per genome/marker combination, but if you have a genome with no markers detected, there will be no row at all for that genome in the concatenated output file. If your species has core genes included in AMRFinderPlus this probably won't be a problem as you would expect some calls for every genome (e.g. AMRFinderPlus will report blaSHV, oqxA, oqxB, fosA in all Klebsiella pneumoniae genomes, so all input genomes will appear in the concatenated output file). An easy solution is to run a check to make sure that all genome names in your input dataset are represented in the genotype table, and if any are missing add empty rows for these using e.g. `tibble(Name=missing_samples) %>% bind_rows(genotype_table)`.

## 2. Phenotype table
The `import_ncbi_ast()` function imports AST data from NCBI format files.

``` {r import_ncbi_ast}
# Example E. coli AST data from NCBI
# This one has already been imported and phenotypes interpreted from assay data
# You can make your own from different file formats, and interpret against breakpoints, using:
#    import_ast("filepath/NCBI_AST.tsv", format="ncbi", interpret_clsi=T)
#    import_ast("filepath/Vitek_AST.tsv", format="vitek", interpret_eucast=T)

ecoli_ast

head(ecoli_ast)
```

Data can be imported from various standard formats using the `import_ast` function, and re-interpreted using latest breakpoints and/or ECOFF. Use `?import_ast` to see the available formats and other options.

If your assay data is not in a standard format, you can wrangle other input data files into the necessary format, manually and/or with the help of the `format_ast` function.

``` {r import_ast_help, eval=F}
?import_ast

?format_ast
```

The phenotype table is long form, with one row for each assay measurement, i.e. one per strain/drug combination.

The essential columns for a phenotype table to work with `AMRgen` functions are:

* `id`: character string giving the sample name, used to link to sample names in the genotype file (this column can have a different name, in which case you'll need to make sure it is the first column in the dataframe OR pass its name to the functions using `pheno_sample_col`)

* `spp_pheno`: species in the form of an AMR package `mo` class (can be created from a column with species name as string, using `AMR::as.mo(species_string)`)

* `drug_agent`: antibiotic name in the form of an AMR package `ab` class (can be created from a column with antibiotic name as string, using `AMR::as.ab(antibiotic_string)`)

* a phenotype column, e.g. the import functions output fields `pheno_eucast`, `pheno_clsi`, `pheno_provided`, `ecoff`: S/I/R phenotype calls in the form of an AMR package `sir` class (can be created from a column with phenotype values as string, using `AMR::as(sir_string)`, or generated by interpreting MIC or disk assay data using `AMR::as.sir`)

If you want to do analyses with raw assay data (e.g. upset plots) you will need that data in one or both of: 

* `mic`: MIC in the form of an AMR package `mic` class (can be created from a column with assay values as string, using `AMR::as.mic(mic_string)`)

* `disk`: disk diffusion zone diameter in the form of an AMR package `disk` class (can be created from a column with assay values as string, using `AMR::as.disk(disk_string)`)

The import functions also standardise names for the following common fields:

* `method`: The laboratory testing method (e.g., "MIC", "disk diffusion", "Etest", "agar dilution")

* `platform`: The laboratory testing platform/instrument if relevant (e.g., "Vitek", "Phoenix", "Sensititre").

* `guideline`: The testing standard recorded in the input file as being used to make the provided phenotype interpretations (e.g. "CLSI", "EUCAST")

* `source`: An identifier for the dataset from which each data point was sourced (e.g. study or hospital name, pubmed ID, bioproject accession).


## 3. Plot phenotype data distribution

It is always a good idea to check the distribution of raw AST data that we have to work with. The function `assay_by_var()` can be used to plot the distribution of MIC or disk measurements, coloured by a variable.
``` {r plot_mic}
# Example E. coli AST data from NCBI

# Plot MIC distribution, coloured by CLSI S/I/R call
assay_by_var(pheno_table=ecoli_ast, antibiotic="Ciprofloxacin", measure="mic", colour_by = "pheno_clsi")

```

It's a good idea to make sure that the `SIR` field in the input data file has been interpreted correctly against the breakpoints. The AMRgen function `checkBreakpoints()` can be used to help look up breakpoints in the `AMR` package. Or, if you provide the function `assay_by_var()` with a species and guideline, it can look up the breakpoints and ECOFF and annotate these directly on the plot.

``` {r plot_mic_breakpoints}
# Look up breakpoints recorded in the AMR package
checkBreakpoints(species="E. coli", guide="CLSI 2025", antibiotic="Ciprofloxacin", assay="MIC")

# Specify species and guideline, to annotate with CLSI breakpoints
assay_by_var(pheno_table=ecoli_ast, antibiotic="Ciprofloxacin", measure="mic", colour_by = "pheno_clsi", species="E. coli", guideline="CLSI 2025")

```

When aggregating AST data from different methods and sources, it is a good idea to check the distributions broken down by method or source. This can be done easily by passing the `assay_by_var()` function a variable name to facet by, which means a separate distribution will be plotted for each value of that variable (e.g. each type of 'method' in our AST test data). Note that this public data from NCBI includes non-standard values in the platform (Sensititre / Sensititer) in the platform
``` {r plot_mic_breakpoints_method, fig.height=8}
# specify facet_var="method" to generate facet plots by assay method
mic_by_platform <- assay_by_var(pheno_table=ecoli_ast, antibiotic="Ciprofloxacin", measure="mic", colour_by = "pheno_clsi", species="E. coli", guideline="CLSI 2025", facet_var ="method")

mic_by_platform$plot
```

## 4. Download reference assay distributions and compare to your data

It can also be helpful to check how your MIC or disk zone distribution compares to the reference distributions, to get a sense of whether your assays were calibrated correctly or if there may be some issues with a given dataset. AMRgen has functions to download the latest reference distributions from EUCAST (mic.eucast.org), and plot them on their own or with your data overlaid.
``` {r get_eucast_distribution}
# get MIC distribution for ciprofloxacin, for all organisms
get_eucast_mic_distribution("cipro")

# specify microorganism to only get results for that pathogen
ecoli_cip_mic_data <- get_eucast_mic_distribution("cipro", "E. coli")

# get disk diffusion data instead
ecoli_cip_disk_data <- get_eucast_disk_distribution("cipro", "E. coli")

# plot the MIC data
mics <- rep(ecoli_cip_mic_data$mic, ecoli_cip_mic_data$count)
ggplot2::autoplot(
  mics,
  ab = "cipro",
  mo = "E. coli",
  title = "E. coli cipro reference distribution"
)
```

``` {r compare_mic_with_eucast}
# Compare reference distribution to random test data
my_mic_values <- AMR::random_mic(500)
comparison <- compare_mic_with_eucast(my_mic_values, ab = "cipro", mo = "E. coli")
comparison
ggplot2::autoplot(comparison)


# Compare reference distribution to example E. coli data
ecoli_cip <- ecoli_ast$mic[ecoli_ast$drug_agent == "CIP"]
comparison <- compare_mic_with_eucast(ecoli_cip, ab = "cipro", mo = "E. coli")
comparison
ggplot2::autoplot(comparison)
```

## 5. Combine genotype and phenotype data for a given drug

The genotype and phenotype tables can include data related to many different drugs, but we need to analyse things one drug at a time. The function `get_binary_matrix()` can be used to extract phenotype data for a specified drug, and genotype data for markers associated with a specified drug class. It returns a single dataframe with one row per strain, for the subset of strains that appear in both the genotype and phenotype input tables. Each row indicates, for one strain, both the phenotypes (with SIR column, any assay columns if desired, and boolean 1/0 coding of R and NWT status) and the genotypes (one column per marker, with boolean 1/0 coding of marker presence/absence).

``` {r get_binary_matrix}
# Get matrix combining phenotype data for ciprofloxacin, binary calls for R/NWT phenotype,
#    and genotype presence/absence data for all markers associated with the relevant drug
#    class (which are labelled "Quinolones" in AMRFinderPlus).
cip_bin <- get_binary_matrix(
  ecoli_geno,
  ecoli_ast,
  antibiotic = "Ciprofloxacin",
  drug_class_list = "Quinolones",
  sir_col = "pheno_clsi",
  keep_assay_values = TRUE,
  keep_assay_values_from = "mic"
)

# check format
head(cip_bin)

# list colnames, to see full list of quinolone markers included
colnames(cip_bin)
```

This binary matrix can be used as the starting a lot of downstream analyses.

For example, we can use it as input to `assay_by_var` to plot the assay distribution coloured by presence of a particular genetic marker
``` {r assay_by_genotype}
assay_by_var(cip_bin %>% dplyr::mutate(drug_agent="CIP"), measure="mic", colour_by="parC_S80I", antibiotic="CIP")$plot

# count the number of gyrA mutations per genome, and colour by that count
gyrA_mut <- cip_bin %>% 
  dplyr::mutate(gyrA_mut = rowSums(across(contains("gyrA_") & where(is.numeric)), na.rm=T)) %>% 
  select(mic, gyrA_mut)

mic_by_gyrA_count <- assay_by_var(gyrA_mut %>% dplyr::mutate(drug_agent="CIP"), measure="mic", colour_by="gyrA_mut", antibiotic="CIP")

mic_by_gyrA_count$plot

# count the number of genetic determinants per genome, and colour by that count
marker_count <- cip_bin %>% 
  mutate(marker_count = rowSums(across(where(is.numeric) & !any_of(c("R","NWT"))), na.rm=T)) %>% 
  select(mic, marker_count)

mic_by_marker_count <- assay_by_var(marker_count %>% dplyr::mutate(drug_agent="CIP"), measure="mic", colour_by="marker_count", antibiotic="CIP", cols=viridisLite::viridis(max(marker_count$marker_count)+1))

mic_by_marker_count$plot

```

## 6. Model a binary drug phenotype using genetic marker presence/absence data

Logistic regression models can be informative to get an overview of the association between a drug resistance phenotype, and each marker thought to be associated with the relevant drug class.

The `amr_logistic()` function uses the `get_binary_matrix` function to generate binary-coded genotype and phenotype data for a specified drug and class; and fits two logistic regression models of the form `R ~ marker1 + marker2 + marker3 + ...` and `NWT ~ marker1 + marker2 + marker3 + ...`. 

Note that the 'NWT' variable in the latter model can be taken either from a precomputed ECOFF-based call of WT=wildtype/NWT=nonwildtype (encoded in the input column `ecoff_col`), or computed from the S/I/R phenotype as NWT=R/I and WT=S.

The `amr_logistic()` function can fit the model using either the standard logistic regression approach implemented in the `glm()` function, or Firth's bias-reduced penalized-likelihood logistic regression implemented in the `logistf` package. The default is to use Firth's regression, as standard logistic regression can fail if there are too observations in some subgroups, which happens quite often with this kind of data. To use `glm()` instead, set `glm=TRUE`.

The function also filters out markers with too few observations in the combined genotype/phenotype dataset. The default minimum is 10 but this can be changed using the `maf` parameter (maf stands for 'minor allele frequency'). If you are having trouble fitting models, it may be because too many markers and combinations have very few observations, and you might try increasing the `maf` value to ensure that rare markers are excluded prior to model fitting.

Using this modelling approach, a negative association with a single marker and phenotype call of R and NWT is a strong indication that marker does not contribute to resistance. Note however that a positive association between a marker and R or NWT does not necessarily imply the marker is independently contributing to the resistance phenotype, as there may be non-independence between markers that is not adequately adjusted for by the model.

The function returns 4 objects:

* `modelR, modelNWT`: data frames summarising each model, with beta coefficient, lower and upper values of 95% confidence intervals, and p-value for each marker (generated from the raw model output using `logistf_details()` or `glm_details()` as relevant)

* `plot`: a ggplot2 object generated from the `modelR` and `modelNWT` objects using the `compare_estimates()` function

* `bin_mat`: the binary matrix used as input to the regression models

``` {r manual_logistic, fig.height=8}
# Manually run Firth's logistic regression model using the binary matrix produced above
dataR <- cip_bin[, setdiff(names(cip_bin), c("id", "pheno", "ecoff", "mic", "NWT"))]
dataR <- dataR[, colSums(dataR, na.rm = TRUE) > 5]
modelR <- logistf::logistf(R ~ ., data = dataR, pl = FALSE)

summary(modelR)

# Extract model summary details using `logistf_details()`
modelR_summary <- logistf_details(modelR)

modelR_summary

# Plot the point estimates and 95% confidence intervals of the model
plot_estimates(modelR_summary)
```

``` {r amr_logistic, fig.height=8}
# Alternatively, use the amr_logistic() function to model R and NWT and plot the results together
models <- amr_logistic(
  geno_table = ecoli_geno,
  pheno_table = ecoli_ast,
  sir_col = "pheno_clsi",
  antibiotic = "Ciprofloxacin",
  drug_class_list = c("Quinolones"),
  maf = 10
)

# Output tables
models$modelR

models$modelNWT

# Note the matrix output is the same as cip_bin, but without the MIC data as this is not required
#    for logistic regression.
models$bin_mat
```

## 7. Assess solo positive predictive value of genetic markers

The strongest evidence of the effect of an individual genetic marker on a drug phenotype is its positive predictive value (PPV) for resistance amongst strains that carry this marker 'solo' with no other markers known to be associated with resistance to the drug class. This is referred to as 'solo PPV'. 

The function `solo_ppv_analysis()` takes as input our genotype and phenotype tables, and calculates solo PPV for resistance to a specific drug (included in our phenotype table) formarkers associated with the specified drug class (included in our genotype table). It uses the `get_binary_matrix()` function to first calculate the binary matrix, then filters out all samples that have more than one marker.

It then calculates for each remaining marker, amongst the genomes in which that marker is found solo, the number of genomes, the number and proportion that are R or NWT, and the 95% confidence intervals for these proportions. The values are returned as a table, and also plotted so we can easily visualise the distribution of S/I/R calls and the solo PPV for R and NWT, for each solo marker.

The function returns 4 objects:

* `solo_stats`: data frame containing the numbers, proportions and confidence intervals for PPV of R and NWT categories

* `amr_binary`: the (wide format) binary matrix for all strains with geno/pheno data for the specified drug/class

* `solo_binary`: the (long format) binary matrix for only those strains in which a solo marker was found, i.e. the data used to calculate PPV

* `combined_plot`: a plot showing the distribution of S/I/R calls and the solo PPV for R and NWT, for each solo marker

``` {r solo_ppv_analysis, fig.height=8}
# Run a solo PPV analysis
soloPPV_cipro <- solo_ppv_analysis(
  ecoli_geno,
  ecoli_ast,
  sir_col = "pheno_clsi",
  antibiotic = "Ciprofloxacin",
  drug_class_list = "Quinolones"
)

# Output table
soloPPV_cipro$solo_stats

# Interim matrices with data used to compute stats and plots
soloPPV_cipro$solo_binary

soloPPV_cipro$amr_binary
```

## 8. Compare markers with assay data

So far we have considered only the impact of individual markers, and their association with categorical S/I/R or WT/NWT calls.

The function `amr_upset()` takes as binary matrix table `cip_bin` summarising ciprofloxacin resistance vs quinolone markers, generated using `get_binary_matrix()`, and explores the distribution of MIC or disk diffusion assay values for all observed combinations of markers (solo or multiple markers). It visualises the data in the form of an upset plot, showing the distribution of assay values and S/I/R calls for each observed marker combination, and returns a summary of these distributions (including sample size, median and interquartile range, number and proportion classified as R).

The function returns 2 objects:

* `summary`: data frame containing summarising the data associated with each combination of markers

* `plot`: an upset plot showing the distribution of assay values, and breakdown of S/I/R calls, for each observed marker combination

``` {r amr_upset, fig.height=8}
# Compare ciprofloxacin MIC data with quinolone marker combinations,
#    using the binary matrix we constructed earlier via get_binary_matrix()
cipro_mic_upset <- amr_upset(
  cip_bin,
  min_set_size = 2,
  assay = "mic",
  order = "value"
)

# Output table
cipro_mic_upset$summary
```
